%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{pysmlib Documentation}
\date{Aug 28, 2018}
\release{2.0.0-rc1+5.g84bef99.dirty}
\author{Davide Marcato}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{pysmlib_logo.png}\par}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


Pysmlib is a Python library which helps creating event based finite state machines
(fsm) for \sphinxhref{http://www.aps.anl.gov/epics/}{Epics Control System}. Each fsm
runs in a different thread and, by default, continues its execution until explicitly
stopped. A convenient loader is provided to help loading multiple fsm together,
thus creating an always-on daemon. Full integration with Epics Channel Access
protocol is provided via \sphinxhref{http://cars9.uchicago.edu/software/python/pyepics3/}{PyEpics}.
The user can connect to Process Variables by defining an fsm input / output (I/O)
and can therefore access its values and changes via convenient methods. The fsm
current state is executed every time one of the connected inputs changes its value
or its connection state, so that the user can evaluate the actions to be
performed, including changing state. In some cases, the user may want to execute
some actions after a certain amount of time (eg: when a timeout expires) and so
the library includes a timer facility which execute the current state after the
specified delay. Other useful features include a simple way to print logs in an
unified way and the possibility to register a specific I/O as watchdog, meaning
that the fsm will automatically write it periodically, so that external systems
can be informed of the online or offline status of the fsm daemon.

The library is designed with network efficiency and system responsiveness
in mind: it’s usually important to act as soon as possible upon the change of an
input, without overflowing the network with useless traffic. This is achieved
by choosing the daemon-like execution, which is the obvious choice in
case of always-on algorithms (eg: a PID) but can be used also for one time
procedures. In fact, an fsm can remain in a idle state, where no action is
performed, until a certain condition is met (eg: a rising edge on the “enable”
input) and then start executing the procedure, finally returning to the idle
state. This means that when the enable arrives, all the I/Os are already
connected and the fsm doesn’t have to wait for all the connection times. The
downside here is the network overload due to many connections which remain active
for a long time. For this reason the I/Os are shared between all the fsm loaded
on the same daemon, so that the minimum number of connections is required. Then,
when an event related to a certain PV arrives, the library executes all the fsm
using that input and guarantees that the input doesn’t change during the state
evaluation and that two or more fsm don’t interfere with each other. As a
result it’s usually recommended to group all the fsm that use related I/Os
in a single daemon, just remember that each fsm is a python thread!

For all these reasons, pysmlib is a great solution to develop high level
automation and control systems in any facility using Epics. It enables
the user to focus on the algorithms to implement without worrying about low-level
problems.


\chapter{Main features include:}
\label{\detokenize{index:main-features-include}}\begin{itemize}
\item {} 
Easy to use and fast development of complex event based fsm - just code the states!

\item {} 
Full EPICS Channel Access integration via PyEpics.

\item {} 
High expandability as provided by all the libraries of Python.

\item {} 
Integrated configurables logging systems.

\item {} 
Convenient methods to access all the information on I/O.

\item {} 
Timers can be used to execute actions after a time delay.

\item {} 
Integrated watchdog logic.

\item {} 
Multi-threading: each fsm is executed on a different thread, sharing I/O.

\item {} 
Convenient loader to launch a daemon with multiple fsm.

\item {} 
Possibility to apply a configurable naming convention on I/O.

\end{itemize}


\section{Download and Installation}
\label{\detokenize{installation:download-and-installation}}\label{\detokenize{installation:id1}}\label{\detokenize{installation::doc}}

\subsection{Prerequisites}
\label{\detokenize{installation:prerequisites}}
This package requires Python version 2.7, while the support for newer version is
still in development. Two modules are mandatory: \sphinxhref{http://www.numpy.org/}{numpy} for
the internal handling of vectors and \sphinxhref{http://cars9.uchicago.edu/software/python/pyepics3/}{PyEpics} which provides the EPICS Channel
Access support. Both are automatically installed when using pip, but you may
have to install the EPICS base on your system and configure \sphinxhref{http://cars9.uchicago.edu/software/python/pyepics3/}{PyEpics} to
locate \sphinxcode{\sphinxupquote{libca}}. See \sphinxhref{http://cars9.uchicago.edu/software/python/pyepics3/}{PyEpics} documentation for further details.

\sphinxhref{http://www.sphinx-doc.org/en/master/}{Sphinx} and its theme \sphinxhref{https://readthedocs.org/}{Read the Docs} are required to build this
documentation.


\subsection{Downloads and Installation}
\label{\detokenize{installation:downloads-and-installation}}
To install, try running:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{pysmlib}
\end{sphinxVerbatim}


\subsubsection{Installing from sources}
\label{\detokenize{installation:installing-from-sources}}
Alternatively, if you want to install from sources:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{git}\PYG{o}{+}\PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{darcato}\PYG{o}{/}\PYG{n}{pysmlib}\PYG{o}{.}\PYG{n}{git}\PYG{n+nd}{@latest}
\end{sphinxVerbatim}

where you can replace \sphinxcode{\sphinxupquote{latest}} with the desired git tag.

Another option is to download the tarball from \sphinxhref{https://github.com/darcato/pysmlib}{Github}, extract it and
then run:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{pysmlib}
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Getting Started}
\label{\detokenize{installation:getting-started}}
Check if the installation was successful by executing:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{epics}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{epics}\PYG{o}{.}\PYG{n}{ca}\PYG{o}{.}\PYG{n}{find\PYGZus{}libca}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

This will print the path of the \sphinxcode{\sphinxupquote{libca}} which will be used. If any error
occurs, then check the installation of \sphinxhref{http://cars9.uchicago.edu/software/python/pyepics3/}{PyEpics}. If you already have EPICS
base compiled on your system you can choose to use its \sphinxcode{\sphinxupquote{libca}} adding the following line to your \sphinxcode{\sphinxupquote{\textasciitilde{}/.bashrc}} file:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{export} \PYG{n}{PYEPICS\PYGZus{}LIBCA}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{path\PYGZus{}to\PYGZus{}your\PYGZus{}epics\PYGZus{}base}\PYG{o}{\PYGZgt{}}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{linux}\PYG{o}{\PYGZhy{}}\PYG{n}{x86\PYGZus{}64}\PYG{o}{/}\PYG{n}{libca}\PYG{o}{.}\PYG{n}{so}
\end{sphinxVerbatim}

replacing \sphinxcode{\sphinxupquote{\textless{}path\_to\_your\_epics\_base\textgreater{}}} with the path to the folder containing your compiled EPICS base.

Moreover you should now be able to import the \sphinxcode{\sphinxupquote{smlib}} package without errors:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{smlib}
\end{sphinxVerbatim}

To start creating your first finite state machine you can give a look at the
examples provided with the package (eventually executing them) and read
{\hyperref[\detokenize{overview:pysmlib-overview}]{\sphinxcrossref{\DUrole{std,std-ref}{Pysmlib overview}}}}.


\subsection{Testing}
\label{\detokenize{installation:testing}}
\sphinxstylestrong{Still in development}

Automatic testing is done with gitlab-ci, which starts a Docker image, installs
pysmlib with all its dependencies, run a simple IOC and executes the test suite.
This can be done for different versions of python. In addition the user can
execute the gitlab-ci script locally or simply run the test suite on his system.

\sphinxstylestrong{TODO}: Add specific instructions.


\subsection{Development Version}
\label{\detokenize{installation:development-version}}
To contribute to the project you can fork it on \sphinxhref{https://github.com/darcato/pysmlib}{Github}, any help is appreciated!
To obtain the latest development version just clone the project:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{darcato}\PYG{o}{/}\PYG{n}{pysmlib}\PYG{o}{.}\PYG{n}{git}
\PYG{n}{cd} \PYG{n}{pysmlib}
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{o}{.}
\end{sphinxVerbatim}

where the \sphinxcode{\sphinxupquote{-e}} automatically updates the installed version when the local
repository is updated.


\subsection{Getting Help}
\label{\detokenize{installation:getting-help}}
For questions, bug reports, feature request, please consider using the
following methods:
\begin{enumerate}
\item {} 
Create an issue on \sphinxhref{https://github.com/darcato/pysmlib}{Github} where it can be discussed.

\item {} 
Send an email to Davide Marcato \textless{}\sphinxhref{mailto:davide.marcato@lnl.infn.it}{davide.marcato@lnl.infn.it}\textgreater{}, or
to the Tech Talk mailing list if the issue is related to EPICS.

\item {} 
If you are sure you have found a bug in existing code, or have
some code you think would be useful to add to pysmlib, consider
making a Pull Request on \sphinxhref{https://github.com/darcato/pysmlib}{Github}.

\end{enumerate}


\subsection{License}
\label{\detokenize{installation:license}}
The whole project is released under the GPLv3 license.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see \textless{}\sphinxurl{https://www.gnu.org/licenses/}\textgreater{}.


\subsection{Acknowledgments}
\label{\detokenize{installation:acknowledgments}}
Pysmlib has been written by Damiano Bortolato \textless{}\sphinxhref{mailto:damiano.bortolato@lnl.infn.i}{damiano.bortolato@lnl.infn.i}\textgreater{}
and Davide Marcato \textless{}\sphinxhref{mailto:davide.marcato@lnl.infn.it}{davide.marcato@lnl.infn.it}\textgreater{} at Legnaro National Laboratories,
INFN. The development started in 2016 in order to have a simpler alternative to
the Epics sequencer to create high level automatization for the RF control
system of the ALPI accelerator. After that it has been separated in a standalone library to be used for the whole SPES project.


\section{Pysmlib overview}
\label{\detokenize{overview:pysmlib-overview}}\label{\detokenize{overview:id1}}\label{\detokenize{overview::doc}}
This section will describe the standard workflow to go from an empty file
editor to a running finite state machine with pysmlib. Each step will be then
explained in detail in the following sections of this documentation.


\subsection{Define your FSM}
\label{\detokenize{overview:define-your-fsm}}
Pysmlib lets you create finite state machines, so the first step is
to adapt your algorithm to a fsm design. This means identifying all
the states required and the conditions that trigger a transition from
one state to another. Furthermore, all the required input and outputs
must be identified: the input are usually needed to determine the
current state and receive events, while the outputs are used to
perform actions on the external world.

The library is designed to be connected to EPICS PVs, so EPICS IOCs must be
running with the required PVs, otherwise the FSM will sleep waiting for the PVs
to connect.


\subsubsection{General structure}
\label{\detokenize{overview:general-structure}}
Each finite state machine is created as a derived class from {\hyperref[\detokenize{fsm:fsmBase}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmBase}}}}},
which is part of pysmlib.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{smlib} \PYG{k}{import} \PYG{n}{fsmBase}

\PYG{k}{class} \PYG{n+nc}{exampleFsm}\PYG{p}{(}\PYG{n}{fsmBase}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{exampleFsm}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
\end{sphinxVerbatim}

In this snippet of code the class is declared and the parent class is
initialized, passing a \sphinxcode{\sphinxupquote{name}} as argument which identifies the
class instance. In fact, when this code will be executed a new thread
will be created for each instance of the class.

\begin{sphinxadmonition}{note}{Note:}
Never forget to include \sphinxcode{\sphinxupquote{**kwargs}} in the arguments of the super class as they are used by the {\hyperref[\detokenize{loader:loader}]{\sphinxcrossref{\DUrole{std,std-ref}{Loader and fsm execution}}}}.
\end{sphinxadmonition}


\subsubsection{Define inputs / outputs}
\label{\detokenize{overview:define-inputs-outputs}}
In the class constructor the I/O must be defined. Note that there is
no actual distinction between a input and a output, both can be read
and written, the only difference is how they will be used. For this
reason the term “input” can be used to indicate both.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{counter} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{testcounter}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mirror} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{testmirror}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{enable} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{testenable}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

The {\hyperref[\detokenize{fsm:connect}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{connect()}}}}} methods requires a string as argument, which is
the name of the EPICS PV to be connected (optional arguments are
available, see {\hyperref[\detokenize{io:accessing-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Accessing I/O}}}}).

Now the inputs will be connected and all their events will be evaluated.
This means that whenever one of those changes its status, the current
state of the FSM will be executed, in order to reevaluate the
conditions to perform an action or to change state.

At the end of the constructor the user must select the first state to
be executed when the fsm is run.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gotoState}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{idle}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Implement states}
\label{\detokenize{overview:implement-states}}
The states are simply defined as class methods, with a special
convention on their names. The basic way of naming them is to give the
desired name, plus \sphinxcode{\sphinxupquote{\_eval}}. For example the \sphinxcode{\sphinxupquote{idle}} state can be
defined like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{idle\PYGZus{}eval}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{enable}\PYG{o}{.}\PYG{n}{rising}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gotoState}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mirroring}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

In this case the FSM will execute this state whenever an input changes
its value and the condition at the second line is evaluated. The
\sphinxcode{\sphinxupquote{rising()}} method will return true only when the enable input (which
must be a binary PV, with a boolean value) goes from 0 to 1. In that
case a transition is triggered and when the next event will arrive,
the state called \sphinxcode{\sphinxupquote{mirroring}} will be executed instead of \sphinxcode{\sphinxupquote{idle}}.
In all the cases where the \sphinxcode{\sphinxupquote{rising()}} method returns false, nothing
will happen and the FSM will remain on the same state.
{\hyperref[\detokenize{fsm:fsm-development}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite State Machine development}}}} describes more in detail the states execution mechanism.

Then other states can be defined, for example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mirroring\PYGZus{}eval}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{enable}\PYG{o}{.}\PYG{n}{falling}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gotoState}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{idle}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mirror}\PYG{o}{.}\PYG{n}{changing}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{readValue} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mirror}\PYG{o}{.}\PYG{n}{val}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mirror}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{n}{readValue}\PYG{p}{)}
\end{sphinxVerbatim}

Here other methods to access the I/O are presented:
\begin{quote}
\begin{description}
\item[{\sphinxcode{\sphinxupquote{val()}}}] \leavevmode
It returns the input value.

\item[{\sphinxcode{\sphinxupquote{put()}}}] \leavevmode
writes a value to an output.

\item[{\sphinxcode{\sphinxupquote{falling()}}}] \leavevmode
It is the opposite of \sphinxcode{\sphinxupquote{rising()}} and returns true when a
falling edge is detected

\item[{\sphinxcode{\sphinxupquote{changing()}}}] \leavevmode
It returns true when the FSM has been executed because the
input has changed its value.

\end{description}
\end{quote}

The resulting effect is that, while enabled, this FSM will read
the value of one input as soon as it changes and write it to another input.
For a complete description of the available methods see {\hyperref[\detokenize{io:accessing-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Accessing I/O}}}}.


\subsection{Load and execute the FSM}
\label{\detokenize{overview:load-and-execute-the-fsm}}
The best approach with FSMs is to keep them simple and with a specific goal, so
multiple instances of the same machine may have to be run with different
parameters, or even multiple different machine can be loaded to implement
multiple algorithms. Pysmlib has been design to offer greater efficiency when
multiple FSMs are loaded together on the same executable, because some resources
can be shared (eg: common inputs).

For these reasons a convenient loader is available. The \sphinxcode{\sphinxupquote{loader.load()}}
function lets you load an instance of your FSM with specific
parameters. At the end the execution begins with the function
\sphinxcode{\sphinxupquote{loader.start()}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{smlib} \PYG{k}{import} \PYG{n}{loader}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} load each fsm}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{loader}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{exampleFsm}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myFirstFsm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} start execution}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{loader}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Now you can execute the FSM simply launching:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{exampleFsm}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

From this moment all the finite state machines will be running until a
kill signal is received (Ctrl-C). This creates an always-on daemon:
for this reason at the end of its algorithm an FSM should not exit
but simply go back to an idle state.

More options can be found at {\hyperref[\detokenize{loader:loader}]{\sphinxcrossref{\DUrole{std,std-ref}{Loader and fsm execution}}}}.


\subsection{Complete example}
\label{\detokenize{overview:complete-example}}
Here is the complete example described in this section:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}! /usr/bin/python}
\PYG{k+kn}{from} \PYG{n+nn}{smlib} \PYG{k}{import} \PYG{n}{fsmBase}\PYG{p}{,} \PYG{n}{loader}

\PYG{c+c1}{\PYGZsh{} FSM definition}
\PYG{k}{class} \PYG{n+nc}{exampleFsm}\PYG{p}{(}\PYG{n}{fsmBase}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{exampleFsm}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{counter} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{testcounter}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mirror} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{testmirror}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{enable} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{testenable}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gotoState}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{idle}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} idle state}
    \PYG{k}{def} \PYG{n+nf}{idle\PYGZus{}eval}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{enable}\PYG{o}{.}\PYG{n}{rising}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gotoState}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mirroring}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} mirroring state}
    \PYG{k}{def} \PYG{n+nf}{mirroring\PYGZus{}eval}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{enable}\PYG{o}{.}\PYG{n}{falling}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gotoState}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{idle}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{elif} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mirror}\PYG{o}{.}\PYG{n}{changing}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{readValue} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mirror}\PYG{o}{.}\PYG{n}{val}\PYG{p}{(}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mirror}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{n}{readValue}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} load each fsm}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{loader}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{exampleFsm}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myFirstFsm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} start execution}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{loader}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

This code is also available in the examples folder.


\section{Finite State Machine development}
\label{\detokenize{fsm:finite-state-machine-development}}\label{\detokenize{fsm:fsm-development}}\label{\detokenize{fsm::doc}}

\subsection{States execution}
\label{\detokenize{fsm:states-execution}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.800\linewidth]{{pysmlib_states}.png}\hspace*{\fill}}

Pysmlib handles all the logic to implement the execution of finite state machine
states. The user only has to implement the actual states, as methods of
{\hyperref[\detokenize{fsm:fsmBase}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmBase}}}}}. Each state can have up to 3 methods defined, for example for a
state called “exampleState” these are:
\begin{quote}
\begin{description}
\item[{\sphinxcode{\sphinxupquote{exampleState\_entry()}} {[}optional{]}}] \leavevmode
This method is executed only once on the transition from previous state
to the current one (“exampleState”). It can be useful for
initializations or to perform specific actions related to the
transition. For example if this is an error state, one could use the
entry part of the error state to perform security actions (like power
off the output of a power supply), and then wait on the \sphinxcode{\sphinxupquote{eval}}
method for a manual reset of the error before continuing. If it is
omitted the \sphinxcode{\sphinxupquote{eval}} method is executed directly.

\item[{\sphinxcode{\sphinxupquote{exampleState\_eval()}} {[}mandatory{]}}] \leavevmode
This the the main body of the state, and the only mandatory part. If
this method is defined, so is the state. If this is the current state,it
is executed every time an event occurs on one of the FSM inputs. Here
the code should check some conditions and when they are met, perform
actions accordingly. These can be a \sphinxcode{\sphinxupquote{put()}} to write a value to an
output or a change of FSM state, by calling \sphinxcode{\sphinxupquote{gotoState("nextStateName")}}. The FSM  will remain in this state and execute this method until the first call to \sphinxcode{\sphinxupquote{gotoState()}}.

\item[{\sphinxcode{\sphinxupquote{exampleState\_exit()}} {[}optional{]}}] \leavevmode
This method is the opposite of the \sphinxcode{\sphinxupquote{entry}} one and is execute only
on the transition from this state to the next one, with no distinction
on the destination. It can be used to perform some clean-up after the
execution of the state and to perform actions related to this
transition.

\end{description}
\end{quote}

This architecture gives easy access to the first and last execution of the
state, which is often useful! Note that after the \sphinxcode{\sphinxupquote{entry}} method the library
does not wait for an event to execute the \sphinxcode{\sphinxupquote{eval}} one, but it is executed right
away. The same is true for the execution of the \sphinxcode{\sphinxupquote{exit}} method after the
\sphinxcode{\sphinxupquote{eval}}.


\subsection{State definition example}
\label{\detokenize{fsm:state-definition-example}}
In this example we will see how to program a FSM state will all the three
methods available.

The goal of this snippet of code is to achieve a motor movement and wait for its
completion before continuing to the next state. Some of the code functionality
are explained on the next pages of this documentation.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} MOVE state}

\PYG{c+c1}{\PYGZsh{} Entry method: executed only the first time}
\PYG{k}{def} \PYG{n+nf}{move\PYGZus{}entry}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{steps} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{smallStep}\PYG{o}{.}\PYG{n}{val}\PYG{p}{(}\PYG{p}{)}            \PYG{c+c1}{\PYGZsh{} get steps to move from a PV}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logI}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Moving }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s2}{ steps...}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{steps}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} write to info log}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{motor}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{n}{steps}\PYG{p}{)}                   \PYG{c+c1}{\PYGZsh{} motor record PV \PYGZhy{} this will move the motor}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{tmrSet}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{moveTimeout}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}          \PYG{c+c1}{\PYGZsh{} Set a timer of 10s}

\PYG{c+c1}{\PYGZsh{} Eval method: executed for each event until gotoState() is called}
\PYG{k}{def} \PYG{n+nf}{move\PYGZus{}eval}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{doneMoving}\PYG{o}{.}\PYG{n}{rising}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}            \PYG{c+c1}{\PYGZsh{} If the motor movement completed}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gotoState}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nextState}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}         \PYG{c+c1}{\PYGZsh{} continue to next state}
    \PYG{k}{elif} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{tmrExp}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{moveTimeout}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}        \PYG{c+c1}{\PYGZsh{} Timer expired event}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gotoState}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{error}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}             \PYG{c+c1}{\PYGZsh{} go to an error state}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logE}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The movement did not complete before timeout reached}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{}write to error log}

\PYG{c+c1}{\PYGZsh{} Exit method: executed only the last time}
\PYG{k}{def} \PYG{n+nf}{move\PYGZus{}exit}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logD}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Motor status word is: }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{motorStatus}\PYG{o}{.}\PYG{n}{val}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} write to debug log}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\end{sphinxVerbatim}


\subsection{Event types}
\label{\detokenize{fsm:event-types}}\label{\detokenize{fsm:id1}}
The events which trigger the execution of the current state are:
\begin{quote}
\begin{description}
\item[{Connection events}] \leavevmode
One of the input has connected or disconnected.

\item[{Change events}] \leavevmode
One of the inputs has changed value.

\item[{Put complete events}] \leavevmode
When a call to \sphinxcode{\sphinxupquote{put()}} is executed the value has to be written over
the network to the PV. This may take some time and after that the put
complete event is notified. When executing a \sphinxcode{\sphinxupquote{put()}} on some kinds of
PVs, these are executed. The event is returned when the execution has
completed.

\item[{Timer expired events}] \leavevmode
These events are local of pysmlib and are used to notify the current
state that a previously set timer has reached its maximum time.

\end{description}
\end{quote}

There are only two situations where a new state is executed without being
triggered by an event:
\begin{enumerate}
\item {} 
The first state is evaluated once at startup.

\item {} 
When a transition from a state to the next one occurs, the next one is   evaluated once right after the previous one, without waiting for an event.

\end{enumerate}

In these cases, all the methods on the inputs which detect edges
({\hyperref[\detokenize{io:io-edges}]{\sphinxcrossref{\DUrole{std,std-ref}{Methods to detect edges}}}}) return false.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{fsmBase}} class reference}
\label{\detokenize{fsm:fsmbase-class-reference}}\index{fsmBase (built-in class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:fsmBase}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{fsmBase}}}{\emph{name}\sphinxoptional{, \emph{tmgr=None}\sphinxoptional{, \emph{ios=None}\sphinxoptional{, \emph{logger=None}}}}}{}
Create an empty FSM: usually you derive from this to add custom states.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the name of the FSM and its related thread.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tmgr}} ({\hyperref[\detokenize{timer:fsmTimers}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmTimers}}}}} object) \textendash{} a timer manager instance

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ios}} ({\hyperref[\detokenize{io:fsmIOs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmIOs}}}}} instance) \textendash{} a container of all the (shared) I/Os available

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{logger}} ({\hyperref[\detokenize{logger:fsmLogger}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmLogger}}}}} instance) \textendash{} a log facility

\end{itemize}

\end{description}\end{quote}

The optional arguments let you pass shared objects. When they are omitted,
they are automatically created by {\hyperref[\detokenize{fsm:fsmBase}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmBase}}}}} from default classes,
while derivate ones can be passed. Usually just one instance of the three
classes is shared between all the FSMs on an executable. The {\hyperref[\detokenize{loader:loader}]{\sphinxcrossref{\DUrole{std,std-ref}{Loader and fsm execution}}}}
automatically takes care of these arguments.

\end{fulllineitems}

\index{gotoState()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:gotoState}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gotoState}}}{\emph{stateName}}{}
Force a transition from the current state to “stateName”. First of all the
\sphinxcode{\sphinxupquote{exit}} method of the current state is executed, then the library will
look for the three methods associated to the string “stateName”, as
described above, will execute the \sphinxcode{\sphinxupquote{entry}} and \sphinxcode{\sphinxupquote{eval}} method, then
wait for an event. When this arrives, the \sphinxcode{\sphinxupquote{stateName\_eval}} method is executed again.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{stateName}} (\sphinxstyleliteralemphasis{\sphinxupquote{String}}) \textendash{} the name of the next state

\end{description}\end{quote}

\end{fulllineitems}

\index{gotoPrevState()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:gotoPrevState}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gotoPrevState}}}{}{}
Return to the previous state

\end{fulllineitems}

\index{fsmname()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:fsmname}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fsmname}}}{}{}
Return the FSM name
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
FSM name.

\end{description}\end{quote}

\end{fulllineitems}

\index{logE()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:logE}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{logE}}}{\emph{msg}}{}
Write to log with ERROR verbosity level = 0.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{msg}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the log message

\end{description}\end{quote}

\end{fulllineitems}

\index{logW()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:logW}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{logW}}}{\emph{msg}}{}
Write to log with WARNING verbosity level = 1.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{msg}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the log message

\end{description}\end{quote}

\end{fulllineitems}

\index{logI()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:logI}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{logI}}}{\emph{msg}}{}
Write to log with INFO verbosity level = 2.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{msg}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the log message

\end{description}\end{quote}

\end{fulllineitems}

\index{logD()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:logD}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{logD}}}{\emph{msg}}{}
Write to log with DEBUG verbosity level = 3.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{msg}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the log message

\end{description}\end{quote}

\end{fulllineitems}

\index{connect()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:connect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{connect}}}{\emph{name}\sphinxoptional{, \emph{**args}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the PV name, or the map reference to a PV name.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} optional arguments to be passed to \sphinxcode{\sphinxupquote{fsmIOs.get()}}

\end{itemize}

\item[{Returns}] \leavevmode
{\hyperref[\detokenize{io:fsmIO}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmIO}}}}} object

\end{description}\end{quote}

The optional arguments can be used by {\hyperref[\detokenize{io:fsmIOs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmIOs}}}}} derivate classes to
get further specification on the desired input. See {\hyperref[\detokenize{io:io-mapping}]{\sphinxcrossref{\DUrole{std,std-ref}{I/O mapping and parametrization}}}}.

\end{fulllineitems}

\index{start()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:start}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{start}}}{}{}
Start FSM execution.

\end{fulllineitems}

\index{kill()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:kill}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{kill}}}{}{}
Stop FSM execution. FSM are derivate of \sphinxcode{\sphinxupquote{threading.Thread}} so they
cannot be restarted after a kill, but a new instance must be created.
However, a better approach is to use an idle state where the FSM will do
nothing, instead of killing it.

\end{fulllineitems}

\index{tmrSet()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:tmrSet}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tmrSet}}}{\emph{name}, \emph{timeout}\sphinxoptional{, \emph{reset=True}}}{}
Create a new timer which will expire in \sphinxtitleref{timeout} seconds, generating an
timer expired event, which will execute the FSM current state (at expiration
time).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} A unique identifier of this timer. The same timer can be reused more than once recalling the same name.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{timeout}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The expiration time, starting from the invocation of {\hyperref[\detokenize{fsm:tmrSet}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmrSet()}}}}}. {[}s{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{reset}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} If this is \sphinxcode{\sphinxupquote{True}} the timer can be re-initialized before expiration. Default = \sphinxcode{\sphinxupquote{True}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{tmrExp()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:tmrExp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tmrExp}}}{\emph{name}}{}
This will return \sphinxcode{\sphinxupquote{True}} if the timer has expired or does not exist.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
timer expired condition

\end{description}\end{quote}

\end{fulllineitems}

\index{isIoConnected()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:isIoConnected}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{isIoConnected}}}{}{}
This will return \sphinxcode{\sphinxupquote{True}} only when all the FSM inputs are connected,
meaning that they have received the first connection event.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{True}} if all I/Os are connected.

\end{description}\end{quote}

\end{fulllineitems}

\index{setWatchdogInput()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:setWatchdogInput}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setWatchdogInput}}}{\emph{input}\sphinxoptional{, \emph{mode="on-off"}\sphinxoptional{, \emph{interval=1}}}}{}
This set an input to be used for the {\hyperref[\detokenize{watchdog:watchdog}]{\sphinxcrossref{\DUrole{std,std-ref}{Watchdog}}}} logic.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{input}} ({\hyperref[\detokenize{io:fsmIO}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmIO}}}}} object.) \textendash{} the input to use as watchdog.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} One of “on-off”, “off”, “on”.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{interval}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the watchdog period {[}s{]}.

\end{itemize}

\item[{Raises}] \leavevmode
ValueError: Unrecognized input type or mode.

\end{description}\end{quote}

\end{fulllineitems}

\index{getWatchdogInput()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fsm:getWatchdogInput}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getWatchdogInput}}}{}{}
Returns the input set as a watchdog or \sphinxcode{\sphinxupquote{None}}.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
watchdog input or \sphinxcode{\sphinxupquote{None}}.

\end{description}\end{quote}

\end{fulllineitems}



\section{Accessing I/O}
\label{\detokenize{io:accessing-i-o}}\label{\detokenize{io:accessing-io}}\label{\detokenize{io::doc}}
Input and Outputs are the only way to comunicate with the external world. In the
context of pysmlib each input is directly mapped to an EPICS PV. Furthermore the
term “input” is used as a generic term for I/O because each input can be also an
output. In fact, all the PVs can be read (get) and written (put).

The main class to access inputs is {\hyperref[\detokenize{io:fsmIO}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmIO}}}}}.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{fsmIO}} class reference}
\label{\detokenize{io:fsmio-class-reference}}\index{fsmIO (built-in class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:fsmIO}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{fsmIO}}}{\emph{...}}{}
This represent an input as an object. The constructor should be never called
directly by the user. Each input is created with the method
{\hyperref[\detokenize{fsm:connect}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{connect()}}}}}, which returns an instance of this class.

\end{fulllineitems}


The user can access the status of each input with some simple, yet powerful,
methods. These are divided in four macro categories:
\begin{itemize}
\item {} 
Methods to access stationary conditions

\item {} 
Methods to detect edges.

\item {} 
Methods to detect trends

\item {} 
Methods to write outputs

\end{itemize}


\subsubsection{Methods for stationary conditions}
\label{\detokenize{io:methods-for-stationary-conditions}}\label{\detokenize{io:io-status}}
These kind of methods return static informations about an input. For example
they can tell if an input is connected or not, but do not give any informations
on when the input has connected: it may have connected yesterday or just a
moment ago.
\index{ioname()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:ioname}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ioname}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the name of the input.

\end{description}\end{quote}

\end{fulllineitems}

\index{val()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:val}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{val}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the current value of the input.

\end{description}\end{quote}

\end{fulllineitems}

\index{connected()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:connected}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{connected}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{True}} if the input is connected, via Channel Access.

\end{description}\end{quote}

\end{fulllineitems}

\index{initialized()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:initialized}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{initialized}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{True}} if the input is connected and has received the first value, meaning its value is not \sphinxcode{\sphinxupquote{None}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{putComplete()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:putComplete}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{putComplete}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{True}} if a previous (or no) {\hyperref[\detokenize{io:put}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{put()}}}}} on this input has completed, \sphinxcode{\sphinxupquote{False}} if a {\hyperref[\detokenize{io:put}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{put()}}}}} is being executed in this moment.

\end{description}\end{quote}

\end{fulllineitems}

\index{pval()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:pval}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pval}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the previous value of the input.

\end{description}\end{quote}

\end{fulllineitems}

\index{data()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data}}}{\emph{key}}{}
PyEpics PV objects contain more informations than value and connection
status. To access those fields, use this method. The available key are listed
here: \textless{}\sphinxurl{http://cars9.uchicago.edu/software/python/pyepics3/pv.html\#user-supplied-callback-functions}\textgreater{}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{key}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the particular information to extract from a PV.

\item[{Returns}] \leavevmode
the requested information.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Methods to detect edges}
\label{\detokenize{io:methods-to-detect-edges}}\label{\detokenize{io:io-edges}}
As described on {\hyperref[\detokenize{fsm:fsm-development}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite State Machine development}}}}, while the FSM is running the current
state is executed exactly once for each event received on any of the FSM inputs,
or timers. With the methods on this group the user can access the information on
the reason why the FSM has been executed at each time. So, for example, if a
connection event is received, the FSM is executed and the method
{\hyperref[\detokenize{io:connecting}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{connecting()}}}}} on the correct input will return \sphinxcode{\sphinxupquote{True}} for just this
execution. After that a change event is received, and the FSM is executed again:
this time the FSM was executed due to a change event, so {\hyperref[\detokenize{io:connecting}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{connecting()}}}}}
will return \sphinxcode{\sphinxupquote{False}}, but the input is still connected and so the
{\hyperref[\detokenize{io:connected}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{connected()}}}}} will still return \sphinxcode{\sphinxupquote{True}}. In fact, this time the
method {\hyperref[\detokenize{io:changing}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{changing()}}}}} will return \sphinxcode{\sphinxupquote{True}}.

So, this way these methods return \sphinxcode{\sphinxupquote{True}} just for one state evaluation, when a
certain event is happening \sphinxtitleref{right now}, and let the user access the information
on rising or falling edges on certain conditions. This is useful when an action
has to be performed only once when an event occurs, and not each time a
condition is true.
\index{rising()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:rising}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{rising}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{True}} if the input has just gone from 0 to not zero. Best to use only with boolean values (binary PVs).

\end{description}\end{quote}

\end{fulllineitems}

\index{falling()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:falling}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{falling}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{True}} if the input has just gone from not zero to 0. Best to use only with boolean values (binary PVs).

\end{description}\end{quote}

\end{fulllineitems}

\index{changing()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:changing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{changing}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{True}} if the input has just changed its value.

\end{description}\end{quote}

\end{fulllineitems}

\index{connecting()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:connecting}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{connecting}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{True}} if the input has just connected.

\end{description}\end{quote}

\end{fulllineitems}

\index{disconnecting()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:disconnecting}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{disconnecting}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{True}} if the input has just disconnected. Note that the Channel Access uses timeouts to check the connection status, so a certain delay is to be expected.

\end{description}\end{quote}

\end{fulllineitems}

\index{initializing()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:initializing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{initializing}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{True}} if the input has just received its first value after a connection.

\end{description}\end{quote}

\end{fulllineitems}

\index{putCompleting()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:putCompleting}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{putCompleting}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{True}} if the input has just completed a previous \sphinxcode{\sphinxupquote{put()}}.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Methods to detect trends}
\label{\detokenize{io:methods-to-detect-trends}}
In scientific applications, when an input has a physical meaning, it is often
useful to filter it, get average value or check the trend over a certain amount
of time. These methods cover most common use cases.
\index{setBufSize()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:setBufSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setBufSize}}}{\emph{numOfElements}}{}
This method has to be called at initialization, or before accessing the
following methods. It creates a buffer of the required lenght where the read
value are stored to be used as the input history.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{numOfElements}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} the buffer lenght

\end{description}\end{quote}

A successive call to this method will discard older buffer and create a new
one, so transient effects can be observed. Numpy arrays are used.

\end{fulllineitems}

\index{valAvg()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:valAvg}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valAvg}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The average value of the elements on the buffer.

\end{description}\end{quote}

Keep in mind that values are accumulated as they arrive, in a event driven
way. This means that if a value does not change for a long time, no event is
generated and the average value may be misleading. In other words: the
values are not weighted with time.

\end{fulllineitems}

\index{valStd()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:valStd}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valStd}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Standard deviation of the elements on the buffer.

\end{description}\end{quote}

\end{fulllineitems}

\index{valTrend()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:valTrend}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valTrend}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
0 = flat, 1 = increasing, -1 = decreasing

\end{description}\end{quote}

code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}avbuf}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)}                 \PYG{c+c1}{\PYGZsh{} Standard deviation}
\PYG{n}{d} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}avbuf}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}avbuf}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} newer element \PYGZhy{} oldest element}
\PYG{k}{if} \PYG{n}{d} \PYG{o}{\PYGZgt{}} \PYG{n}{s}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mi}{1}
\PYG{k}{if} \PYG{n}{d} \PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZhy{}}\PYG{n}{s}\PYG{p}{:}
    \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{k}{return} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsubsection{Methods to write outputs}
\label{\detokenize{io:methods-to-write-outputs}}
At least, of course, this method can be used to write a new value to a output.
\index{put()}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:put}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{put}}}{\emph{newValue}}{}
Write \sphinxtitleref{newValue} to output.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{newValue}} (\sphinxstyleliteralemphasis{\sphinxupquote{type depends on PV type}}) \textendash{} the value to be written

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{False}} if {\hyperref[\detokenize{io:put}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{put()}}}}} failed, \sphinxcode{\sphinxupquote{True}} otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subsection{I/O mapping and parametrization}
\label{\detokenize{io:i-o-mapping-and-parametrization}}\label{\detokenize{io:io-mapping}}
The inputs on pysmlib are shared resources. The class which groups all the
inputs from all the FSMs is:
\index{fsmIOs (built-in class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:fsmIOs}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{fsmIOs}}}
This is a container of all inputs of all FSMs. It can be instantiated by the
user and passed to all the FSMs as a optional argument (\sphinxcode{\sphinxupquote{ios}}, see
{\hyperref[\detokenize{fsm:fsmBase}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmBase}}}}}) on their constructor, but the easiest way is to use
the {\hyperref[\detokenize{loader:loader}]{\sphinxcrossref{\DUrole{std,std-ref}{Loader and fsm execution}}}} which automatically handles FSM optional arguments.

This class declares a method \sphinxcode{\sphinxupquote{get()}} which receives a string with the
input name, creates the corresponding input, if not already available,
and returns it. It is used by {\hyperref[\detokenize{fsm:connect}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{connect()}}}}} and should not be accessed
directly.

\end{fulllineitems}


Using the {\hyperref[\detokenize{io:fsmIOs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmIOs}}}}} each input name must be exactly a PV name. This
approach has some disadvantages:
\begin{enumerate}
\item {} 
The PV name is hard-coded in the FSM implementation. If, for any reason,the PV name changes, the code must be modified!!

\item {} 
The names are not parametric. If your logic works well for two identical objects, with PV names which differ only for a number (eg: PS01 vs PS02) you will have to implement manually a parametrization mechanism for each FSM.

\item {} 
Inserting long PV names in the code is not much readable.

\item {} 
The user has to check each PV name to be compatible with the Naming Convention of the facility, if present.

\end{enumerate}

For all these reasons a derivate class of {\hyperref[\detokenize{io:fsmIOs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmIOs}}}}} has been developed.
\index{mappedIOs (built-in class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io:mappedIOs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{mappedIOs}}}{\emph{mapFile}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{mapFile}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the path to a map file, whose syntax is described below.

\end{description}\end{quote}

\end{fulllineitems}


This let you use short names to identify inputs, and add any number of optional
arguments to specify custom parameters. For example, you can define an input
like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{exampleFsm}\PYG{p}{(}\PYG{n}{fsmBase}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{n}{psNum}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{exampleFsm}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ps} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{powerSupply}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{n}\PYG{o}{=}\PYG{n}{psNum}\PYG{p}{)}
\end{sphinxVerbatim}

This way, the number of the power supply is a parameter of the FSM and you can
instantiate multiple FSMs, one for each power supply. Moreover, inside the code
the “powerSupply” string is easy to read and

Then the input name has to be somehow translated to the correct PV name, which
is, in our example, “PS01”. For this reason a map file has to be defined,
containing the following lines:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}} \PYG{n}{pattern} \PYG{o}{=} \PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{p}{:}\PYG{o}{.}\PYG{l+m+mi}{2}\PYG{n}{s}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZob{}}\PYG{p}{:}\PYG{l+m+mi}{02}\PYG{n}{d}\PYG{p}{\PYGZcb{}}\PYG{p}{)} \PYG{p}{(}\PYG{n}{OBJ}\PYG{p}{,} \PYG{n}{NUM}\PYG{p}{)}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{powerSupply}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZlt{}}\PYG{n}{n}\PYG{o}{\PYGZgt{}}      \PYG{c+c1}{\PYGZsh{}this is a comment}
\end{sphinxVerbatim}

As you can see the first thing to do is to define a pattern, which is the naming
convention followed by all the PVs who are defined after (before the next
pattern). In this case the pattern specify that the PV name must contain two
characters, followed by an integer with 2 digits, with leading zeroes. This way
the translator knows what to expect, can correctly format numbers and can check
that the inputs respect this Naming Convention. The syntax of the pattern
definition is the same as the one used by python \sphinxcode{\sphinxupquote{format()}} function.

The second line defines the string “powerSupply”: this is the string that we
will use inside our code to refer to that particular input. After the equal mark
we can find the informations to fill the pattern to create the PV name. In
particular the first two characters are provided directly: “PS”. Note that the
quotation marks are optional and will be stripped away. The second part
instead, which is put inside the \sphinxcode{\sphinxupquote{\textless{} \textgreater{}}} signs, represent a parameters. This
means that its value is not know before run time, and must be passed as an
optional argument (with the exact same name) to the {\hyperref[\detokenize{fsm:connect}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{connect()}}}}} method. In
fact, we provided the optional argument \sphinxcode{\sphinxupquote{n}}. So, at execution time the
translator will format the number as required, concatenate it to the first two
characters and obtain “PS01”. This offer great flexibility to connect to similar
PVs who differ only for some counters.

A more complete example of a map file is the following one:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}MACROS DEFINITION:
\PYGZgt{} FAC = \PYGZdq{}Al\PYGZdq{}
\PYGZgt{} APP = \PYGZdq{}Llrf\PYGZdq{}
\PYGZgt{} SAPP = \PYGZdq{}Cryo\PYGZdq{}
\PYGZgt{} CHID = \PYGZdq{}A\PYGZdq{}
\PYGZgt{} OBJ = \PYGZdq{}Qwrs\PYGZdq{}
\PYGZgt{} AMP = \PYGZdq{}Ampl\PYGZdq{}
\PYGZgt{} CVON = \PYGZdq{}Cvon\PYGZdq{}
\PYGZgt{} CRYG = \PYGZdq{}Cryg\PYGZdq{}

\PYGZsh{}LONG PVS:
\PYGZgt{} pattern = (\PYGZob{}:.2s\PYGZcb{}\PYGZob{}:.4s\PYGZcb{}\PYGZob{}:.4s\PYGZcb{}\PYGZob{}:02d\PYGZcb{}\PYGZob{}:.1s\PYGZcb{}\PYGZus{}\PYGZob{}:.4s\PYGZcb{}\PYGZob{}:02d\PYGZcb{}\PYGZob{}:.1s\PYGZcb{}\PYGZob{}:s\PYGZcb{}) (FAC, APP, SAPP, NSAP, CHID, OBJ, NOBJ, TYPE, SIGNAL)
\PYGZdq{}CvonEn\PYGZdq{}             = \PYGZdl{}(FAC), \PYGZdl{}(APP), \PYGZdl{}(SAPP), \PYGZlt{}nsap\PYGZgt{}, \PYGZdl{}(CHID), \PYGZdl{}(CVON), \PYGZlt{}nobj\PYGZgt{}, \PYGZdq{}:\PYGZdq{}, \PYGZdq{}ProcEn\PYGZdq{}         \PYGZsh{}enable fsm
\PYGZdq{}CvonRetc\PYGZdq{}           = \PYGZdl{}(FAC), \PYGZdl{}(APP), \PYGZdl{}(SAPP), \PYGZlt{}nsap\PYGZgt{}, \PYGZdl{}(CHID), \PYGZdl{}(CVON), \PYGZlt{}nobj\PYGZgt{}, \PYGZdq{}:\PYGZdq{}, \PYGZdq{}Retc\PYGZdq{}           \PYGZsh{}fsm return code
\PYGZdq{}CvonMsgs\PYGZdq{}           = \PYGZdl{}(FAC), \PYGZdl{}(APP), \PYGZdl{}(SAPP), \PYGZlt{}nsap\PYGZgt{}, \PYGZdl{}(CHID), \PYGZdl{}(CVON), \PYGZlt{}nobj\PYGZgt{}, \PYGZdq{}:\PYGZdq{}, \PYGZdq{}Msgs\PYGZdq{}           \PYGZsh{}message to user
\PYGZdq{}CvonStat\PYGZdq{}           = \PYGZdl{}(FAC), \PYGZdl{}(APP), \PYGZdl{}(SAPP), \PYGZlt{}nsap\PYGZgt{}, \PYGZdl{}(CHID), \PYGZdl{}(CVON), \PYGZlt{}nobj\PYGZgt{}, \PYGZdq{}:\PYGZdq{}, \PYGZdq{}Stat\PYGZdq{}           \PYGZsh{}state of the fsm
\PYGZdq{}CvonRunn\PYGZdq{}           = \PYGZdl{}(FAC), \PYGZdl{}(APP), \PYGZdl{}(SAPP), \PYGZlt{}nsap\PYGZgt{}, \PYGZdl{}(CHID), \PYGZdl{}(CVON), \PYGZlt{}nobj\PYGZgt{}, \PYGZdq{}:\PYGZdq{}, \PYGZdq{}Runn\PYGZdq{}           \PYGZsh{}running status the fsm
\PYGZdq{}CvonWdog\PYGZdq{}           = \PYGZdl{}(FAC), \PYGZdl{}(APP), \PYGZdl{}(SAPP), \PYGZlt{}nsap\PYGZgt{}, \PYGZdl{}(CHID), \PYGZdl{}(CVON), \PYGZlt{}nobj\PYGZgt{}, \PYGZdq{}:\PYGZdq{}, \PYGZdq{}Wdog\PYGZdq{}           \PYGZsh{}state of the fsm

\PYGZsh{}SHORTER PVS
\PYGZgt{} pattern = (\PYGZob{}:.2s\PYGZcb{}\PYGZob{}:.4s\PYGZcb{}\PYGZob{}:.4s\PYGZcb{}\PYGZob{}:02d\PYGZcb{}\PYGZob{}:.1s\PYGZcb{}\PYGZob{}:.1s\PYGZcb{}\PYGZob{}:s\PYGZcb{}) (FAC, APP, SAPP, NSAP, CHID, TYPE, SIGNAL)
\PYGZdq{}cryoName\PYGZdq{}           = \PYGZdl{}(FAC), \PYGZdl{}(APP), \PYGZdl{}(SAPP), \PYGZlt{}nsap\PYGZgt{}, \PYGZdl{}(CHID), \PYGZdq{}:\PYGZdq{}, \PYGZdq{}Name\PYGZdq{}                           \PYGZsh{}cryostat string name
\PYGZdq{}cryoNext\PYGZdq{}           = \PYGZdl{}(FAC), \PYGZdl{}(APP), \PYGZdl{}(SAPP), \PYGZlt{}nsap\PYGZgt{}, \PYGZdl{}(CHID), \PYGZdq{}:\PYGZdq{}, \PYGZdq{}Next\PYGZdq{}                           \PYGZsh{}pointer to next cryostat
\PYGZdq{}cryoPrev\PYGZdq{}           = \PYGZdl{}(FAC), \PYGZdl{}(APP), \PYGZdl{}(SAPP), \PYGZlt{}nsap\PYGZgt{}, \PYGZdl{}(CHID), \PYGZdq{}:\PYGZdq{}, \PYGZdq{}Prev\PYGZdq{}                           \PYGZsh{}pointer to prev cryostat
\PYGZdq{}cryoNQwrs\PYGZdq{}          = \PYGZdl{}(FAC), \PYGZdl{}(APP), \PYGZdl{}(SAPP), \PYGZlt{}nsap\PYGZgt{}, \PYGZdl{}(CHID), \PYGZdq{}:\PYGZdq{}, \PYGZdq{}Nqwr\PYGZdq{}                           \PYGZsh{}n of qwr in this cryostat
\PYGZdq{}cryogEn\PYGZdq{}            = \PYGZdl{}(FAC), \PYGZdl{}(CRYG), \PYGZdl{}(SAPP), \PYGZlt{}nsap\PYGZgt{}, \PYGZdl{}(CHID), \PYGZdq{}:\PYGZdq{}, \PYGZdq{}RfpaEn\PYGZdq{}                        \PYGZsh{}enable from cryogenic
\PYGZdq{}storeConnWd\PYGZdq{}        = \PYGZdl{}(FAC), \PYGZdl{}(APP), , , , \PYGZdq{}:\PYGZdq{}, \PYGZdq{}StorWd\PYGZdq{}                                             \PYGZsh{}store fsm connection watchdog
\end{sphinxVerbatim}

Syntax rules:
\begin{itemize}
\item {} 
The character \sphinxcode{\sphinxupquote{\#}} is used for comments.

\item {} \begin{description}
\item[{The character \sphinxcode{\sphinxupquote{\textgreater{}}} signal special lines.}] \leavevmode\begin{itemize}
\item {} 
The word \sphinxcode{\sphinxupquote{pattern}} is reserved to define a new pattern on special lines.

\item {} 
All the other cases are macro definitions.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Each normal line defines a input name and its link to a PV name.}] \leavevmode\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{\$( )}} string means that the part inside parentesis is a macro name and should be replaced with its value

\item {} 
The \sphinxcode{\sphinxupquote{\textless{} \textgreater{}}} string indicates a parameter that should be passed as optional argument of {\hyperref[\detokenize{fsm:connect}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{connect()}}}}}

\end{itemize}

\end{description}

\item {} 
Each element of the PV name is divided by a comma, and each part is associated with the one on the pattern, in order.

\end{itemize}

Macro definition is used to avoid repeting the same string everywhere in the
file, so each macro occurrence is substituted with its value on the whole
document. For example, having defined the marco \sphinxcode{\sphinxupquote{\textgreater{} FAC = "Al"}}, \sphinxcode{\sphinxupquote{\$(FAC)}}
is replaced with \sphinxcode{\sphinxupquote{Al}}.

Therefore, when defining an input, one of the string on the left can be used,
and then the PV name will be built concatenating all the pieces following the
pattern logic, and replacing the parameters with the values passed at run time.


\subsubsection{Summary of the steps to implement a map on inputs}
\label{\detokenize{io:summary-of-the-steps-to-implement-a-map-on-inputs}}\begin{enumerate}
\item {} 
Use {\hyperref[\detokenize{io:mappedIOs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{mappedIOs}}}}} instead of {\hyperref[\detokenize{io:fsmIOs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmIOs}}}}}. This is achieved by calling \sphinxcode{\sphinxupquote{loader.setIoMap()}} function.

\item {} 
Create the map file.

\item {} 
Connect to the inputs using the strings defined in the map file, passing all the required parameters as optional arguments.

\end{enumerate}


\section{Logger}
\label{\detokenize{logger:logger}}\label{\detokenize{logger:id1}}\label{\detokenize{logger::doc}}
All the log messages should be printed with the methods available in
{\hyperref[\detokenize{fsm:fsmBase}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmBase}}}}}. This ensures that they are threaded in a coherent way. In the
loader a verbosity level can be specified, so that only the messages with
verbosity level lower or equal to that are printed. For example a verbosity of
zero is related to ERROR logging, and messages are always printed, while a
higher verbosity may be useful only while debugging.

There are three options to log:


\subsection{Log to Standard Output}
\label{\detokenize{logger:log-to-standard-output}}
This is the easiest method, and the default one if no other is specified. Should
be used only while developing or on small tests. All the messages are written to
the standard output of the console where the executable is launched.

This is achieved via a base class called {\hyperref[\detokenize{logger:fsmLogger}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmLogger}}}}}.
\index{fsmLogger (built-in class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logger:fsmLogger}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{fsmLogger}}}{\sphinxoptional{\emph{level=3}}}{}
Collect all the log messages from the various FSMs loaded and print them to
stdout.

\end{fulllineitems}


This can be used by creating an instance and passing it as an optional argument
to all the FSMs, or (better) using the {\hyperref[\detokenize{loader:module-loader}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{loader}}}}} with no option specified. The verbosity can be set with \sphinxcode{\sphinxupquote{setVerbosity()}} function.


\subsection{Log to File}
\label{\detokenize{logger:log-to-file}}
A better approach is to write logs to file, in order to open them only when
needed. For this reason a derivate class of the previous one has been developed:
\index{fsmFileLogger (built-in class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logger:fsmFileLogger}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{fsmFileLogger}}}{\sphinxoptional{\emph{level=3}\sphinxoptional{, \emph{directory="logs/"}\sphinxoptional{, \emph{prefix=""}}}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{level}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} the log level

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the folder where all the log files will be written

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prefix}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} a common prefix for all the logs of this executable

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


This will write one file for each instance of FSM loaded in the executable, and
will use the prefix, plus the name of the FSM to name the file.

It can be used directly by  creating an instance and passing it as an optional
argument to all the FSMs, or (better) using the {\hyperref[\detokenize{loader:module-loader}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{loader}}}}} and its
\sphinxcode{\sphinxupquote{logToFile()}} function. The verbosity can be set with \sphinxcode{\sphinxupquote{setVerbosity()}} function.


\subsection{Log to Syslog}
\label{\detokenize{logger:log-to-syslog}}
\sphinxstylestrong{Planned}


\subsection{Examples}
\label{\detokenize{logger:examples}}
Choosing the logging method:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{smblib} \PYG{k}{import} \PYG{n}{loader}

\PYG{n}{loader}\PYG{o}{.}\PYG{n}{setVerbosity}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} INFO verbosity}
\PYG{n}{loader}\PYG{o}{.}\PYG{n}{logToFile}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZti{}/fsmlogs/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{exampleDaemon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} comment this line to log to stdout}

\PYG{n}{loader}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{p}{)} \PYG{c+c1}{\PYGZsh{} load your FSMs}

\PYG{n}{loader}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Using log functions inside the FSM code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mymethod\PYGZus{}eval}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logE}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is an ERROR level log message!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logW}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is an WARNING level log message!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logI}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is an INFO level log message!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{logD}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is an DEBUG level log message!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Loader and fsm execution}
\label{\detokenize{loader:loader-and-fsm-execution}}\label{\detokenize{loader:loader}}\label{\detokenize{loader::doc}}
The loader is provided help the user create a single launcher of many FSMs
sharing resources. All the configuration options are available via convenient
methods. It takes care of instantiating the classes for loggers, timers, and
shared inputs and all the instances of the user defined FSM as required.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{loader}} module}
\label{\detokenize{loader:module-loader}}\label{\detokenize{loader:loader-module}}\index{loader (module)}\index{loader.setVerbosity() (in module loader)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{loader:loader.loader.setVerbosity}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{loader.}}\sphinxbfcode{\sphinxupquote{setVerbosity}}}{\emph{level}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{level}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The verbosity level: all the messages with lower or equal level are printed.

\end{description}\end{quote}

\end{fulllineitems}

\index{loader.setVerbosity() (in module loader)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{loader.}}\sphinxbfcode{\sphinxupquote{setVerbosity}}}{\emph{levelStr}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{levelStr}} \textendash{} The verbosity level, one of “error”, “warning”, “info”,”debug”.

\end{description}\end{quote}

The available verbosity levels are:
\begin{itemize}
\item {} 
Error: these messages are always printed, and contain critical information on failures.

\item {} 
Warning: these messages are printed only when the verbosity level is 1 or higher.

\item {} 
Info: these messages are printed only when the verbosity level is 2 or higher

\item {} 
Debug: these messages are printed only when the verbosity level is 3 or higher. They contain a lot of detailed information useful while debugging applications.

\end{itemize}

\end{fulllineitems}

\index{loader.logToFile() (in module loader)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{loader:loader.loader.logToFile}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{loader.}}\sphinxbfcode{\sphinxupquote{logToFile}}}{\emph{path}, \emph{prefix}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} The path of a directory where to store all the logs. Can be both relative or absolute.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prefix}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} A prefix for log file names, to identify all the logs belonging to this executable.

\end{itemize}

\end{description}\end{quote}

While logging to file, a file will be created for each FSM loaded, plus one
more for all the information on the main thread. If this function is called,
the logger will be instantiated from {\hyperref[\detokenize{logger:fsmFileLogger}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmFileLogger}}}}} instead of the
default one ({\hyperref[\detokenize{logger:fsmLogger}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmLogger}}}}}).

\end{fulllineitems}

\index{loader.setIoMap() (in module loader)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{loader:loader.loader.setIoMap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{loader.}}\sphinxbfcode{\sphinxupquote{setIoMap}}}{\emph{ioMapPath}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ioMapPath}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The path of a file defining a map for the inputs. See {\hyperref[\detokenize{io:mappedIOs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{mappedIOs}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{loader.load() (in module loader)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{loader:loader.loader.load}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{loader.}}\sphinxbfcode{\sphinxupquote{load}}}{\emph{myFsmClass}, \emph{name}, \emph{...}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{myFsmClass}} \textendash{} The definition of a FSM.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The unique name of this FSM instance.

\end{itemize}

\end{description}\end{quote}

This function is used to load multiple FSM in this executable. The first
parameter is the FSM class, not one of its instances. In fact, the loader
will create the instance, adding the required optional arguments to the
constructor. Then an arbitrary number of parameters can be passed, as
required by each different FSM constructor.

\end{fulllineitems}

\index{loader.start() (in module loader)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{loader:loader.loader.start}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{loader.}}\sphinxbfcode{\sphinxupquote{start}}}{}{}
This is usually the last function to be called: it starts the execution of
all the loaded FSMs and suspends the main thread, waiting for a signal.

The supported signals are:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*} \PYG{n}{SIGINT} \PYG{p}{(}\PYG{n}{Ctrl}\PYG{o}{\PYGZhy{}}\PYG{n}{C}\PYG{p}{)}\PYG{p}{:} \PYG{n}{Terminate} \PYG{n}{the} \PYG{n}{execution} \PYG{n}{of} \PYG{n+nb}{all} \PYG{n}{the} \PYG{n}{FSMs}\PYG{o}{.}
\PYG{o}{*} \PYG{n}{SIGUSR1}\PYG{p}{:} \PYG{n}{Print} \PYG{n}{a} \PYG{n}{report} \PYG{n}{of} \PYG{n+nb}{all} \PYG{n}{the} \PYG{n}{inputs} \PYG{n}{connections}\PYG{o}{.}
\end{sphinxVerbatim}

In this way each FSM is executed in a separate thread until the kill signal
is received.

\end{fulllineitems}



\subsection{Example}
\label{\detokenize{loader:example}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{smlib} \PYG{k}{import} \PYG{n}{loader}
\PYG{k+kn}{from} \PYG{n+nn}{myfsm} \PYG{k}{import} \PYG{n}{myfsm}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} logger options}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{loader}\PYG{o}{.}\PYG{n}{setVerbosity}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{debug}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{}\PYGZsh{}use only this if you want to print log to shell}
\PYG{n}{loader}\PYG{o}{.}\PYG{n}{logToFile}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mypath}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{daemon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{}\PYGZsh{}use also this if you want to print to file}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} inputs options}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{loader}\PYG{o}{.}\PYG{n}{setIoMap}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pathToMapFile}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{}this will set the map file path}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} load each fsm}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{loader}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{myfsm}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fsm1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ciao}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{come}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{va?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{loader}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{myfsm}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fsm2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ciao}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} start execution}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{loader}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{How to run the application}
\label{\detokenize{loader:how-to-run-the-application}}
All the parameters are specified via the loader, so you can easily run the
application with python. For example, if the example above is saved on a file
named \sphinxcode{\sphinxupquote{myDaemon.py}}, you can execute it with:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{myDaemon}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

and it can be stopped by the \sphinxcode{\sphinxupquote{Ctrl-C}} key combination or (on linux) with:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pkill} \PYG{o}{\PYGZhy{}}\PYG{n}{SIGINT} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{myDaemon}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

If you want to print a report on the connected inputs, during execution run:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pkill} \PYG{o}{\PYGZhy{}}\PYG{n}{SIGUSR1} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{myDaemon}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

and check logs for the output. This will not affect FSM execution.


\section{Timers}
\label{\detokenize{timer:timers}}\label{\detokenize{timer:id1}}\label{\detokenize{timer::doc}}

\subsection{How to use timers}
\label{\detokenize{timer:how-to-use-timers}}
The FSM execution, as explained on {\hyperref[\detokenize{fsm:fsm-development}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite State Machine development}}}}, is event-driven. This
means that no code will be executed, until an event (eg: an input changes its
value) triggers the execution of the current state.

In some situations you may want to run some code at a specific time,
independently from the inputs. For example you may want to run periodic actions
with fixed delay, or wait for “timeout” delays. For these reasons the timers
have been introduces: they let you develop a FSM with asynchronous execution
model.

The basic usage can be seen in the following example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{move\PYGZus{}entry}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{motor}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}                     \PYG{c+c1}{\PYGZsh{} move the motor}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{tmrSet}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{moveTimeout}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}          \PYG{c+c1}{\PYGZsh{} Set a timer of 10s}

\PYG{k}{def} \PYG{n+nf}{move\PYGZus{}eval}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{doneMoving}\PYG{o}{.}\PYG{n}{rising}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}            \PYG{c+c1}{\PYGZsh{} If the motor movement completed}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gotoState}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nextState}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}         \PYG{c+c1}{\PYGZsh{} continue to next state}
    \PYG{k}{elif} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{tmrExp}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{moveTimeout}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}        \PYG{c+c1}{\PYGZsh{} Timer expired event}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gotoState}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{error}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}             \PYG{c+c1}{\PYGZsh{} go to an error state}
\end{sphinxVerbatim}

As seen in the example, timers are available as methods of the {\hyperref[\detokenize{fsm:fsmBase}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmBase}}}}}
class. After moving the motor, a timer is set with {\hyperref[\detokenize{fsm:tmrSet}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmrSet()}}}}} which means
that after 10 seconds a special event will be generated and the method
{\hyperref[\detokenize{fsm:tmrExp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmrExp()}}}}} will return \sphinxcode{\sphinxupquote{True}}. This way the user can perform
appropriate actions when a movement takes too long to complete.

\begin{sphinxadmonition}{note}{Note:}
The {\hyperref[\detokenize{fsm:tmrExp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmrExp()}}}}} method returns \sphinxcode{\sphinxupquote{True}} even before the timer is set, and will continue to return \sphinxcode{\sphinxupquote{True}} after expiration until it is set again.
\end{sphinxadmonition}

Timers are identified with a string, which should be unique. When reusing the
same string, the same timer is used and if it is not expired, it is restarted.
To avoid it being restarted, use a third optional parameter of {\hyperref[\detokenize{fsm:tmrSet}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmrSet()}}}}}:
\sphinxcode{\sphinxupquote{reset}} and set it to \sphinxcode{\sphinxupquote{False}}.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{fsmTimers}} class}
\label{\detokenize{timer:fsmtimers-class}}\index{fsmTimers (built-in class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{timer:fsmTimers}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{fsmTimers}}}
This class handles all the timers of all the FSMs as shared resources. It
can be used by creating an instance and passing it as an optional argument
to all the FSMs, or (better) using the {\hyperref[\detokenize{loader:module-loader}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{loader}}}}} which automatically
manages it.

\end{fulllineitems}



\section{Watchdog}
\label{\detokenize{watchdog:watchdog}}\label{\detokenize{watchdog:id1}}\label{\detokenize{watchdog::doc}}
When using pysmlib all the FSM logic is not directly connected to the EPICS IOC
as is the case for the EPICS sequencer. This means that if the pysmlib
executable crashes or it loses network connection, all the FSM logic will stop
to work, while the IOC continues to live without noticing it. In some cases this
can be a problem and you may want at least to trigger a warning for someone to
check the situation. For this reason a mechanism has to be implemented to inform
the IOC about the “online” status of the FSM executable.

An easy way of doing it is to implement a \sphinxtitleref{watchdog} logic, that is define a
special input where to perform a periodic {\hyperref[\detokenize{io:put}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{put()}}}}} and signal an “offline”
status when no {\hyperref[\detokenize{io:put}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{put()}}}}} is received for a time longer than the period.


\subsection{IOC side: definition of the PV}
\label{\detokenize{watchdog:ioc-side-definition-of-the-pv}}
For this purpose a special kind of PV can be used: a binary output. This
particular record type has a field called \sphinxcode{\sphinxupquote{HIGH}} which sets the time its value
must remain high (that is to 1) after receiving a \sphinxcode{\sphinxupquote{put(1)}}. So, it is
sufficient to write to it from a FSM with a smaller period to keep it always at
1. Then, if the value goes to 0 the FSM is recognized as offline.

The PV (one for each FSM) can be defined like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}watchdog}
\PYG{n}{record} \PYG{p}{(}\PYG{n}{bo}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{watchdog}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{field} \PYG{p}{(}\PYG{n}{DESC}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FSM watchdog}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{field} \PYG{p}{(}\PYG{n}{DTYP}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Soft Channel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{field} \PYG{p}{(}\PYG{n}{DOL}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{field} \PYG{p}{(}\PYG{n}{HIGH}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} keep the 1 value for 20s after the put}
    \PYG{n}{field} \PYG{p}{(}\PYG{n}{PINI}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{field} \PYG{p}{(}\PYG{n}{ZNAM}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Disconnected}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{field} \PYG{p}{(}\PYG{n}{ONAM}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Connected}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Refer to the EPICS documentation for more informations on how to define PVs
inside an IOC.


\subsection{FSM side: the watchdog input}
\label{\detokenize{watchdog:fsm-side-the-watchdog-input}}
To signal being online each FSM has to perform periodic {\hyperref[\detokenize{io:put}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{put()}}}}} to its
watchdog PV. This can be easily achieved with the {\hyperref[\detokenize{fsm:setWatchdogInput}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{setWatchdogInput()}}}}}
method of {\hyperref[\detokenize{fsm:fsmBase}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fsmBase}}}}}: it is sufficient to pass to it a standard input
(created with {\hyperref[\detokenize{fsm:connect}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{connect()}}}}}) and set two parameters:
\begin{enumerate}
\item {} \begin{description}
\item[{The watchdog mode, which can be:}] \leavevmode\begin{enumerate}
\item {} 
“on-off”: A \sphinxcode{\sphinxupquote{put}} is performed periodically, once to 1 and once to 0.

\item {} 
“off”: A \sphinxcode{\sphinxupquote{put(0)}} is performed periodically.

\item {} 
“on”: A \sphinxcode{\sphinxupquote{put(1)}} is performed periodically.

\end{enumerate}

\end{description}

\item {} 
The watchdog period in seconds.

\end{enumerate}


\subsubsection{Example}
\label{\detokenize{watchdog:example}}
In the following example the input \sphinxcode{\sphinxupquote{wdog}} is used as watchdog. A \sphinxcode{\sphinxupquote{put(1)}}
will be automatically performed to it every 5s, as long as the FSM is running.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{exampleFsm}\PYG{p}{(}\PYG{n}{fsmBase}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{exampleFsm}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{wdog} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{exampleWdog}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{setWatchdogInput}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{wdog}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{on}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interval}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}

    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}


\section{Advanced}
\label{\detokenize{advanced:advanced}}\label{\detokenize{advanced::doc}}

\subsection{Understanding event handling}
\label{\detokenize{advanced:understanding-event-handling}}
The event described in {\hyperref[\detokenize{fsm:event-types}]{\sphinxcrossref{\DUrole{std,std-ref}{Event types}}}} above are defined by Channel Access
but it can be important to understand exactly their behaviour, to avoid getting
strange results in edge conditions.

When the user call the method {\hyperref[\detokenize{fsm:connect}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{connect()}}}}}, the library will look on the
local network and search (via UDP broadcasts) for any IOC declaring a PV with
the desired name. This may take a small amount of time. After that a TCP
connection is created with the IOC, if not already available. In fact, the same
TCP connection to an IOC is shared for all the PVs declared on that IOC. Now the
Channel Access protocol registers a monitor on those PVs, so that each time they
change status, an event is generated by the IOC and sent to the FSM. This is
similar to an interrupt mechanism, so that pysmlib doesn’t have to constantly
poll for changes, which would kill network performances. When the connection
finally is set up, two events reaches the FSM, hopefully in this order:
\begin{enumerate}
\item {} 
A connection event, with \sphinxcode{\sphinxupquote{connected}} set to \sphinxcode{\sphinxupquote{True}} and \sphinxcode{\sphinxupquote{value}} set    to \sphinxcode{\sphinxupquote{None}}.

\item {} 
A change event, with \sphinxcode{\sphinxupquote{value}} set to the new value.

\end{enumerate}

This means that it is not sufficient to wait for the connection to be able to
read an input, but the first change event must have arrived. In cases where
multiple inputs are connected at the same time, it can arrive multiple events
later. For this reason there is a specific method to check the availability
of the first value after a connection: {\hyperref[\detokenize{io:initialized}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{initialized()}}}}}. This will return
\sphinxcode{\sphinxupquote{True}} if an input is connected and has received its first value.

Pysmlib has been designed so that the status of an input does not change while
executing a state. This means that the code is executed exactly once per event
received, and the updates brought by the events are available only after they
are evaluated. For example, when a change event arrives, it is added to a FIFO
list. When all the preceding events have been evaluated, the event is removed
from the list, its new value is written to the corresponding input and the
current state is executed. In cases where there are a lot of received events,
there may be a certain delay between the time of arrival and the time when it is
evaluated. For this reason it is important to keep the states simple and non-blocking.


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{l}
\item {\sphinxstyleindexentry{loader}}\sphinxstyleindexpageref{loader:\detokenize{module-loader}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}